module Authentications.View exposing (index)

import Dict exposing (Dict)
import Set exposing (Set)
import Html exposing (Html, text)
import Html.Attributes as Attr exposing (class)
import Html.Events
import Bootstrap.Table as Table
import Bootstrap.Button as Button
import Markdown
import Utils exposing (ite)
import Repo exposing (Repo)
import Repo.Messages exposing (Msg(..))
import Repo.ViewParts exposing (textInputWithValidation, textInputRequired, select)
import Authentications as Auth exposing (Authentication, AuthType(..))
import ViewParts exposing (stdBtn, cardBlock, anchoredText)


-- Index


index : Set Repo.EntityId -> Repo {} Authentication -> Html (Msg Authentication)
index usedAuthIds authRepo =
    let
        ( hipchatAuthDict, otherAuthDict ) =
            Dict.partition (\id auth -> auth.data.type_ == Hipchat) authRepo.dict

        thWithWidth ( label, width ) =
            Table.th [ Table.cellAttr (Attr.style [ ( "width", toString width ++ "%" ) ]) ] [ text label ]

        table labels createRow dict =
            Table.table
                { options = [ Table.striped, Table.hover, Table.small, Table.bordered, Table.responsive ]
                , thead = labels |> List.map thWithWidth |> Table.simpleThead
                , tbody = dict |> Repo.dictToSortedList authRepo.sort |> List.map (authRow usedAuthIds) |> (::) createRow |> Table.tbody []
                }
    in
        Html.div []
            [ hipchatAuthDict
                |> table [ ( "Token", 80 ), ( "Actions", 20 ) ] (createHipchatRow authRepo)
                |> cardBlock
                    [ ViewParts.fa [ class "align-bottom mx-1" ] 2 (Auth.typeToFa Hipchat)
                    , anchoredText "Hipchat Notification Tokens"
                    ]
                    "Room notification token generated by room admin."
                    Nothing
            , otherAuthDict
                |> table [ ( "Label", 20 ), ( "Type", 10 ), ( "Token", 50 ), ( "Actions", 20 ) ] (createOtherRow authRepo.dirtyDict)
                |> cardBlock
                    [ ViewParts.fa [ class "align-bottom mx-1" ] 2 (Auth.typeToFa Raw)
                    , anchoredText "Other Credentials"
                    ]
                    "Credentials that go to `Authorization` header on request."
                    (Just otherDescription)
            , deleteModal authRepo.deleteModal
            ]


otherDescription : Html msg
otherDescription =
    Markdown.toHtml [ class "small" ] """
- `Bearer` type: `Authorization : Bearer TOKEN0123456789`
- `Raw` type: `Authorization : TOKEN0123456789`
"""


authRow : Set Repo.EntityId -> Repo.Entity Authentication -> Table.Row (Msg Authentication)
authRow usedAuthIds auth =
    let
        maskedToken =
            Utils.stringIndexedMap (\i x -> ite (i < 5) x '*')

        ( isDisabled, deleteButtonString ) =
            ite (Set.member auth.id usedAuthIds) ( True, "Used" ) ( False, "Delete" )
    in
        [ ite (auth.data.type_ == Hipchat) Nothing (Just (text auth.data.name))
        , ite (auth.data.type_ == Hipchat) Nothing (Just (text (toString auth.data.type_)))
        , Just (Html.pre [ class "mb-0" ] [ text (maskedToken auth.data.token) ])
        , Just (stdBtn Button.danger [ Button.onClick (ConfirmDelete auth), Button.small ] isDisabled deleteButtonString)
        ]
            |> List.filterMap identity
            |> List.map (List.singleton >> Table.td [ Table.cellAttr (class "align-middle") ])
            |> Table.tr []


createHipchatRow : Repo {} Authentication -> Table.Row (Msg Authentication)
createHipchatRow { dict, dirtyDict } =
    let
        (( { data }, audit ) as dirtyEntity) =
            Repo.dirtyGetWithDefault "newHipchat" (Auth.hipchatToken "") dirtyDict

        isDuplicateToken input =
            dict
                |> Repo.dictToList
                |> List.any (\x -> x.data.type_ == Hipchat && x.data.token == input)

        validate input =
            ite (isDuplicateToken input) (Just "Already registered") (Repo.required input)

        isValid =
            Auth.isValid dirtyEntity
    in
        [ [ Html.form [ Attr.id "auth-hipchat", Html.Events.onSubmit (ite isValid (Create "newHipchat" data) NoOp) ] []
          , textInputWithValidation "auth-hipchat" "Token" True audit "newHipchat" [ "token" ] validate Auth.hipchatToken data.token
          ]
        , [ registerButton "auth-hipchat" isValid ]
        ]
            |> List.map (Table.td [ Table.cellAttr (class "align-middle") ])
            |> Table.tr []


createOtherRow : Repo.DirtyDict Authentication -> Table.Row (Msg Authentication)
createOtherRow dirtyDict =
    let
        (( { data }, audit ) as dirtyEntity) =
            Repo.dirtyGetWithDefault "new" Auth.dummyAuthentication dirtyDict

        typeSelect =
            [ Raw, Bearer ]
                |> List.map (\type_ -> ( (Utils.toLowerString type_), toString type_, data.type_ == type_ ))
                |> select "auth-other" "Type" True "new" (\x -> { data | type_ = Auth.stringToType x })

        isValid =
            Auth.isValid dirtyEntity
    in
        [ [ Html.form [ Attr.id "auth-other", Html.Events.onSubmit (ite isValid (Create "new" data) NoOp) ] []
          , textInputRequired "auth-other" "Label" True audit "new" [ "label" ] (\x -> { data | name = x }) data.name
          ]
        , [ typeSelect ]
        , [ textInputRequired "auth-other" "Token" True audit "new" [ "token" ] (\x -> { data | token = x }) data.token ]
        , [ registerButton "auth-other" isValid ]
        ]
            |> List.map (Table.td [ Table.cellAttr (class "align-middle") ])
            |> Table.tr []


registerButton : String -> Bool -> Html (Msg Authentication)
registerButton formId enabled =
    stdBtn
        Button.primary
        [ Button.attrs [ Attr.form formId, Attr.type_ "submit" ], Button.small ]
        (not enabled)
        "Register"


deleteModal : Repo.ModalState Authentication -> Html (Msg Authentication)
deleteModal { isShown, target } =
    ViewParts.modal
        (always CancelDelete)
        isShown
        [ class "modal-sm" ]
        [ text ("Deleting '" ++ target.data.name ++ "'") ]
        [ Html.p [] [ text "Are you sure?" ] ]
        [ stdBtn Button.danger [ Button.onClick (Delete target.id) ] False "Yes, delete"
        , stdBtn Button.secondary [ Button.onClick (CancelDelete) ] False "Cancel"
        ]
