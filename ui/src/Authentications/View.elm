module Authentications.View exposing (listView)

import Dict exposing (Dict)
import Set exposing (Set)
import Html exposing (Html, text)
import Html.Attributes as Attr exposing (class)
import Html.Events
import Html.Utils exposing (toggleSortOnClick, mx2Button, anchoredText)
import Bootstrap.Table as Table
import Bootstrap.Button as Button
import Bootstrap.Form.Input as Input
import Bootstrap.Form.Select as Select
import Markdown
import Utils exposing (ite)
import Repo exposing (Repo)
import Repo.Messages exposing (Msg(..))
import Authentications as Auth exposing (Authentication, AuthType(Hipchat))
import Poller.Assets
import Error


listView : Bool -> Dict String Utils.Url -> Set Repo.EntityId -> Repo Authentication -> Html (Msg Authentication)
listView isDev inventory usedAuthIds authRepo =
    let
        ( hipchatAuthDict, otherAuthDict ) =
            Dict.partition (\id auth -> auth.data.type_ == Hipchat) authRepo.dict

        cardBlock titleContents subtitle description contents =
            Html.div [ class "card mb-4" ]
                [ Html.div [ class "card-block" ]
                    [ Html.h4 [ class "card-title" ] titleContents
                    , Html.p [ class "card-subtitle text-muted" ]
                        [ Markdown.toHtml [] subtitle ]
                    , Html.div [ class "card-text" ] [ description ]
                    , contents
                    ]
                ]

        thWithWidth ( label, width ) =
            Table.th [ Table.cellAttr (Attr.style [ ( "width", toString width ++ "%" ) ]) ] [ text label ]

        table labels createRow dict =
            Table.table
                { options = [ Table.striped, Table.hover, Table.small, Table.bordered ]
                , thead = labels |> List.map thWithWidth |> Table.simpleThead
                , tbody = dict |> Repo.dictToSortedList authRepo.sort |> List.map (authRow usedAuthIds) |> (::) createRow |> Table.tbody []
                }

        otherDescription =
            Markdown.toHtml [ class "small" ] """
- `Bearer` type: `Authorization : Bearer TOKEN0123456789`
- `Raw` type: `Authorization : TOKEN0123456789`
            """
    in
        Html.div []
            [ hipchatAuthDict
                |> table [ ( "Token", 80 ), ( "Actions", 20 ) ] (createHipchatRow authRepo)
                |> cardBlock
                    [ Html.img [ Attr.src (Poller.Assets.url isDev inventory "img/hipchat_square_40.png"), class "align-bottom mx-1", Attr.alt "Hipchat" ] []
                    , anchoredText "Hipchat Notification Tokens"
                    ]
                    "Room notification token generated by room admin."
                    (text "")
            , otherAuthDict
                |> table [ ( "Label", 20 ), ( "Type", 10 ), ( "Token", 50 ), ( "Actions", 20 ) ] (createOtherRow authRepo.dirtyDict)
                |> cardBlock [ anchoredText "Other Credentials" ] "Credentials that go to `Authorization` header on request." otherDescription
            , deleteModalView authRepo.deleteModal
            ]


authRow : Set Repo.EntityId -> Repo.Entity Authentication -> Table.Row (Msg Authentication)
authRow usedAuthIds auth =
    let
        maskedToken =
            Utils.stringIndexedMap (\i x -> ite (i < 5) x '*')

        ( deleteButtonOptions, deleteButtonString ) =
            if Set.member auth.id usedAuthIds then
                ( [ Button.disabled True, Button.small ], "Used" )
            else
                ( [ Button.danger, Button.small ], "Delete" )
    in
        [ ite (auth.data.type_ == Hipchat) Nothing (Just (text auth.data.name))
        , ite (auth.data.type_ == Hipchat) Nothing (Just (text (toString auth.data.type_)))
        , Just (Html.pre [ class "mb-0" ] [ text (maskedToken auth.data.token) ])
        , Just (mx2Button (OnDeleteModal auth True) deleteButtonOptions deleteButtonString)
        ]
            |> List.filterMap identity
            |> List.map (List.singleton >> Table.td [ Table.cellAttr (class "align-middle") ])
            |> Table.tr []


createHipchatRow : Repo.Repo Authentication -> Table.Row (Msg Authentication)
createHipchatRow { dict, dirtyDict } =
    let
        currentHipchat =
            Utils.dictGetWithDefault "newHipchat" (Repo.dummyEntity (Auth.hipchatToken "")) dirtyDict

        onInput token =
            OnEdit "newHipchat" { currentHipchat | data = Auth.hipchatToken token } []

        existingHipchatTokens =
            let
                filter ( _, auth ) =
                    case auth.data.type_ of
                        Hipchat ->
                            Just auth.data.token

                        _ ->
                            Nothing
            in
                dict
                    |> Dict.toList
                    |> List.filterMap filter

        onSubmitMsg =
            if List.member currentHipchat.data.token existingHipchatTokens then
                (SetErrors [ Error.one Error.ValidationError "Already Registered" currentHipchat.data.token ])
            else
                (OnSubmitNew currentHipchat.data)
    in
        [ [ Html.form [ Attr.id "auth-hipchat", Html.Events.onSubmit onSubmitMsg ] [] -- Using HTML5 form association. Unsupported in Edge/IE11
          , inlineInput "auth-hipchat" "auth-hipchat-token" "(New Token)" currentHipchat.data.token onInput
          ]
        , [ registerButton "auth-hipchat" (currentHipchat.data.token == "") ]
        ]
            |> List.map (Table.td [ Table.cellAttr (class "align-middle") ])
            |> Table.tr []


createOtherRow : Repo.EntityDict Authentication -> Table.Row (Msg Authentication)
createOtherRow dirtyDict =
    let
        currentOther =
            Utils.dictGetWithDefault "new" (Repo.dummyEntity Auth.dummyAuthentication) dirtyDict

        currentData =
            currentOther.data

        onInput newData =
            OnEdit "new" { currentOther | data = newData } []

        typeSelect =
            Select.select
                [ Select.id "auth-type"
                , Select.onInput (\type_ -> onInput { currentData | type_ = Auth.stringToType type_ })
                , Select.small
                ]
                [ Select.item [ Attr.value "raw", Attr.selected (currentData.type_ == Auth.Raw) ] [ text "Raw" ]
                , Select.item [ Attr.value "bearer", Attr.selected (currentData.type_ == Auth.Bearer) ] [ text "Bearer" ]
                ]
    in
        [ [ Html.form [ Attr.id "auth-other", Html.Events.onSubmit (OnSubmitNew currentData) ] []
          , inlineInput "auth-other" "auth-other-name" "(Label)" currentData.name (\name -> onInput { currentData | name = name })
          ]
        , [ typeSelect ]
        , [ inlineInput "auth-other" "auth-other-token" "(New Token)" currentData.token (\token -> onInput { currentData | token = token }) ]
        , [ registerButton "auth-other" (currentData.token == "") ]
        ]
            |> List.map (Table.td [ Table.cellAttr (class "align-middle") ])
            |> Table.tr []


inlineInput : String -> String -> String -> String -> (String -> Msg Authentication) -> Html (Msg Authentication)
inlineInput formId inputId placeholder currentValue onInput =
    Input.text
        [ Input.id inputId
        , Input.attrs [ Attr.form formId ]
        , Input.onInput onInput
        , Input.small
        , Input.placeholder placeholder
        , Input.value currentValue
        ]


registerButton : String -> Bool -> Html (Msg Authentication)
registerButton formId isDisabled =
    Button.button
        [ Button.attrs [ Attr.form formId, Attr.type_ "submit", class "mx-2", class "my-1" ]
        , Button.disabled isDisabled
        , Button.primary
        , Button.small
        ]
        [ text "Register" ]


deleteModalView : Repo.ModalState Authentication -> Html (Msg Authentication)
deleteModalView { isShown, target } =
    Html.Utils.modal
        (OnDeleteModal target)
        isShown
        [ class "modal-sm" ]
        [ text ("Deleting '" ++ target.data.name ++ "'") ]
        [ Html.p [] [ text "Are you sure?" ] ]
        [ mx2Button (OnDeleteConfirmed target.id) [ Button.danger ] "Yes, delete"
        , mx2Button (OnDeleteModal target False) [ Button.secondary ] "Cancel"
        ]
